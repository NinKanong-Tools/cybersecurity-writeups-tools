# DNSRECON


### What is dnsrecon?
DNSRecon is a command-line tool used for DNS reconnaissance, enumeration, and information gathering. It is designed to be used by security professionals and ethical hackers to assess the security of a network and identify potential vulnerabilities. DNSRecon can be used to perform the following tasks:
  - Enumeration of subdomains
  - Retrieval of DNS records
  - Brute-forcing of subdomains
  - Zone transfers
  - Reverse DNS lookups




````
dnsrecon
````
<img width="738" height="132" alt="image" src="https://github.com/user-attachments/assets/89ce8eec-7e4c-42d2-be66-2ff3a2e34819" />


#### 1. Basic Enumeration
````
dnsrecon -d google.com
````
<img width="506" height="327" alt="image" src="https://github.com/user-attachments/assets/27946b43-708d-4966-a218-6c593a3f8823" />

- -d: This is a flag or option that stands for "domain". It tells the dnsrecon tool to target the domain specified immediately after it.
- Performs standard DNS enumeration.

````
dnsrecon -r 74.125.130.0-74.125.130.200
````
<img width="537" height="307" alt="image" src="https://github.com/user-attachments/assets/d46d2a2b-3938-42c1-a36d-a918f5a26a03" />

<img width="411" height="220" alt="image" src="https://github.com/user-attachments/assets/9ab039f2-99cd-4ee8-8e07-50c013fae1a2" />

#### 2. Zone Transfer Test (AXFR)
````
dnsrecon -d zonetransfer.me -t axfr

````
<img width="664" height="380" alt="image" src="https://github.com/user-attachments/assets/ec958ff1-ffef-4bed-befd-2f662d94c4ca" />

- -d zonetransfer.me: Target domain
- -t axfr: Attempt a DNS zone transfer


#### 3. Brute Force Subdomains

````
dnsrecon -d kali.org -D /usr/share/wordlists/dnsmap.txt -t brt
````
<img width="722" height="521" alt="image" src="https://github.com/user-attachments/assets/9403647c-0895-4307-ba46-3ad90a33a321" />

- This command attempts to discover subdomains of kali.org by trying every word in dnsmap.txt as a possible subdomain
- -D /usr/share/wordlists/dnsmap.txt : Wordlist for brute-forcing subdomains
- -t brt : Type:brute-force ( brt = brute)


#### 4. SRV Record Enumeration
````
dnsrecon -d microsoft.com -t srv
````
<img width="767" height="128" alt="image" src="https://github.com/user-attachments/assets/55be101a-d91d-4519-8ea0-fde02a707f46" />

- -t srv : Query for SRV (Service) records


#### 5. Top-Level Domain (TLD) Expansion
````
dnsrecon -d kali.org -t tld
````
<img width="551" height="489" alt="image" src="https://github.com/user-attachments/assets/aeaa752a-163f-4082-a170-eec2b022eef9" />

<img width="441" height="491" alt="image" src="https://github.com/user-attachments/assets/c9b2424d-a86d-47c8-8102-d140c0188ed4" />


#### 6. Standard Record Enumeration
````
dnsrecon -d kali.org -t std
````
<img width="997" height="625" alt="image" src="https://github.com/user-attachments/assets/964f4bf6-96cc-491f-ac6e-6454ff53b583" />

- Enumerates standard records (A, NS, MX, SOA).
- -t std : Specifies the type of scan:Standard DNS enumeration


#### 7. Zone Walking (NSEC / DNSSEC)
````
dnsrecon -d cloudflare.com -t zonewalk
````
<img width="439" height="185" alt="image" src="https://github.com/user-attachments/assets/83f826d8-7236-451d-b47c-120b3c8c7247" />

- This command used to perform a zone walk (also known as DNS zone transfer enumeration) against the domain "cloudflare.com".
- -t zonewalk : Type of scan: Attempt a DNS zone transfer (AXFR) using NSEC records (also called "NSEC walking").


#### 8. Output Results to File
````
dnsrecon -d kali.org -t std --json kali-dns.json
````
<img width="1002" height="441" alt="image" src="https://github.com/user-attachments/assets/090bb6cf-7679-4aa5-ab48-c6191f66ee75" />

- Saves results to JSON, XML, or CSV.
- -t std : Scan type:Standard DNS lookup (A, AAAA, MX, TXT, SOA, NS, etc.)
- --json kali-dns.json : Save output to a file named kali-dns.json in JSON format.


#### 9. Using Specific Nameserver
````
dnsrecon -d google.com -n 1.1.1.1
````
<img width="503" height="388" alt="image" src="https://github.com/user-attachments/assets/2d9e47f0-2469-4599-b524-549b23f354a1" />

<img width="729" height="311" alt="image" src="https://github.com/user-attachments/assets/674ae5aa-bdb5-45c3-88d3-baba413f659c" />

- Forces queries to use Google DNS instead of system resolver.
- -n 1.1.1.1: Uses the specified DNS server (in this case, Cloudflare's public DNS) to perform the queries.


#### 10 Reverse Brute force
````
dnsrecon -d kali.org -D /usr/share/wordlists/dnsmap.txt -t rvs
````
<img width="710" height="514" alt="image" src="https://github.com/user-attachments/assets/b499a9bb-6878-4759-9b2b-5526f5739840" />

- -D /usr/share/wordlists/dnsmap.txt : Uses the specified wordlist for subdomain brute-forcing.
- -t brt : Enables brute-force mode, trying each word in the wordlist as a subdomain.


### If we want to combine it in one 
- first we need to create wordlist like:
````
mousepad wordlist.txt
````
<img width="505" height="642" alt="image" src="https://github.com/user-attachments/assets/c360ec6b-91fe-48a5-94a2-0e39fa45556d" />

- we start scan
````
dnsrecon -d example.com -t std -t srv -t brt -D wordlist.txt -n 8.8.8.8 --json output.json
````

- if we want to see output
````
cat output.json
````
<img width="920" height="159" alt="image" src="https://github.com/user-attachments/assets/64b7fa69-e3f8-428e-af7a-80db7f8dd02d" />



### To better understand how DNS enumeration works under the hood, I created a Python script using the `dnspython` library.  
I used an AI assistant to generate the initial draft, then I reviewed, tested, and modified the code to ensure I understood how it worked.
````
#!/usr/bin/env python3

import argparse
import dns.resolver
import dns.reversename
import dns.zone
import dns.query
import json
import sys
from ipaddress import ip_network
from typing import List, Dict, Any

DEFAULT_DNS = ["1.1.1.1", "8.8.8.8"]

def resolve_record(domain: str, record_type: str, dns_server: str = None) -> List[str]:
    """Resolve DNS record of given type."""
    resolver = dns.resolver.Resolver()
    if dns_server:
        resolver.nameservers = [dns_server]
    try:
        answers = resolver.resolve(domain, record_type)
        return [str(rdata) for rdata in answers]
    except Exception:
        return []

def enumerate_standard(domain: str, dns_server: str = None) -> Dict[str, Any]:
    """Perform standard DNS enumeration."""
    records = {}
    types = ['A', 'AAAA', 'MX', 'TXT', 'NS', 'CNAME', 'SOA']
    
    print(f"[*] Enumerating standard records for {domain}...")
    for rtype in types:
        result = resolve_record(domain, rtype, dns_server)
        if result:
            records[rtype] = result
            for r in result:
                print(f"[+] {rtype:6} {domain} -> {r}")

    txt_records = records.get('TXT', [])
    spf_records = [txt for txt in txt_records if 'v=spf' in txt]
    if spf_records:
        records['SPF'] = spf_records

    return records

def brute_force_subdomains(domain: str, wordlist_file: str, dns_server: str = None, verbose: bool = False):
    """Brute-force subdomains using a wordlist."""
    found = []
    print(f"[*] Starting brute-force on {domain} using {wordlist_file}...")
    try:
        with open(wordlist_file, 'r') as f:
            subdomains = [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        print(f"[-] Wordlist {wordlist_file} not found.")
        return found

    wildcard_test = f"unlikelyrandomsubdomain123.{domain}"
    wildcard_ips = set(resolve_record(wildcard_test, 'A', dns_server))

    for sub in subdomains:
        subdomain = f"{sub}.{domain}"
        a_records = resolve_record(subdomain, 'A', dns_server)
        aaaa_records = resolve_record(subdomain, 'AAAA', dns_server)
        if a_records or aaaa_records:
            current_ips = set(a_records)
            if wildcard_ips and current_ips == wildcard_ips:
                continue
            entry = {
                'subdomain': subdomain,
                'A': a_records,
                'AAAA': aaaa_records
            }
            found.append(entry)
            ip_str = ', '.join(a_records + aaaa_records)
            print(f"[+] Found: {subdomain} [{ip_str}]")
    return found

def reverse_lookup(cidr: str, dns_server: str = None):
    """Perform reverse DNS (PTR) lookup on a CIDR range."""
    found = []
    print(f"[*] Performing reverse lookup on {cidr}...")
    try:
        network = ip_network(cidr, strict=False)
    except ValueError as e:
        print(f"[-] Invalid CIDR {cidr}: {e}")
        return found

    for ip in network.hosts():
        try:
            rev_name = dns.reversename.from_address(str(ip))
            result = dns.resolver.resolve(rev_name, "PTR")
            for rdata in result:
                hostname = str(rdata).rstrip('.')
                print(f"[+] PTR {ip} -> {hostname}")
                found.append({'ip': str(ip), 'hostname': hostname})
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer, dns.resolver.Timeout):
            continue
    return found

def check_zone_transfer(domain: str, dns_server: str = None):
    """Attempt DNS zone transfer."""
    print(f"[*] Attempting AXFR zone transfer for {domain}...")
    ns_servers = resolve_record(domain, 'NS', dns_server)
    if not ns_servers:
        print("[-] No NS records found.")
        return []

    found_zones = []
    for ns in ns_servers:
        ns = ns.rstrip('.')  
        try:
            print(f"[*] Trying AXFR on nameserver: {ns}")
            ns_ip = resolve_record(ns, 'A', dns_server)[0]
            zone = dns.zone.from_xfr(dns.query.xfr(ns_ip, domain))
            names = list(zone.nodes.keys())
            for n in names:
                name = str(n)
                if name != '@':
                    fqdn = f"{name}.{domain}" if name != '@' else domain
                    record_type = zone[n].to_text(name)
                    print(f"[+] AXFR {fqdn} from {ns}")
                    found_zones.append({'ns': ns, 'record': str(record_type)})
        except Exception as e:
            print(f"[-] AXFR failed on {ns}: {str(e)}")
    return found_zones

def main():
    parser = argparse.ArgumentParser(description="Python-based DNS reconnaissance tool (like dnsrecon)")
    parser.add_argument("-d", "--domain", help="Domain to enumerate")
    parser.add_argument("-r", "--range", help="CIDR range for reverse lookup (e.g., 192.168.1.0/24)")
    parser.add_argument("-D", "--wordlist", help="Wordlist for subdomain brute-forcing")
    parser.add_argument("-n", "--dns", help="Custom DNS server (e.g., 1.1.1.1)", default=None)
    parser.add_argument("-t", "--type", choices=['std', 'brt', 'rvl', 'axfr', 'all'], 
                        action='append', help="Type of scan to perform")
    parser.add_argument("--json", help="Save output to JSON file")
    parser.add_argument("--threads", type=int, help="Number of threads (not used here, placeholder)", default=1)
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    if not args.type:
        print("[-] Please specify at least one scan type with -t")
        parser.print_help()
        sys.exit(1)

    results = {
        'target': args.domain or args.range,
        'scan_types': args.type,
        'results': {}
    }

    if 'std' in args.type or 'all' in args.type:
        if not args.domain:
            print("[-] Domain required for std scan.")
        else:
            results['results']['standard'] = enumerate_standard(args.domain, args.dns)

    if 'brt' in args.type or 'all' in args.type:
        if not args.domain or not args.wordlist:
            print("[-] Domain and wordlist required for brute-force.")
        else:
            results['results']['bruteforce'] = brute_force_subdomains(args.domain, args.wordlist, args.dns, args.verbose)

    if 'rvl' in args.type or 'all' in args.type:
        if not args.range:
            print("[-] CIDR range (-r) required for reverse lookup.")
        else:
            results['results']['reverse'] = reverse_lookup(args.range, args.dns)

    if 'axfr' in args.type or 'all' in args.type:
        if not args.domain:
            print("[-] Domain required for zone transfer check.")
        else:
            results['results']['axfr'] = check_zone_transfer(args.domain, args.dns)

    if args.json:
        with open(args.json, 'w') as f:
            json.dump(results, f, indent=4)
        print(f"\n[+] Results saved to {args.json}")

    print("\n[*] Scan completed.")

if __name__ == "__main__":
    main()
````

I use it in VSCode cause it easy to use.
When i run this script it will show 

<img width="953" height="396" alt="image" src="https://github.com/user-attachments/assets/7ee370d3-4456-4fbc-8cf3-689dffea20ae" />

````
/bin/python /home/k4n0ng/Documents/scanning/Scanning_Tools.py/dnsrecon.py -d kali.org -t std
````
<img width="847" height="336" alt="image" src="https://github.com/user-attachments/assets/9a76c585-97c7-4cc5-b99b-d5c5c9f0eb97" />

- We can use any commands like
````
/bin/python /home/k4n0ng/Documents/scanning/Scanning_Tools.py/dnsrecon.py -d kali.org -D /usr/share/wordlists/dnsmap.txt -t brt

/bin/python /home/k4n0ng/Documents/scanning/Scanning_Tools.py/dnsrecon.py -r 192.168.1.0/24 -t rvl

/bin/python /home/k4n0ng/Documents/scanning/Scanning_Tools.py/dnsrecon.py -d kali.org -t axfr

/bin/python /home/k4n0ng/Documents/scanning/Scanning_Tools.py/dnsrecon.py -d kali.org -D /usr/share/wordlists/dnsmap.txt -t all --json output.json
````


#### ==========>> End of DNSRECON



### Practice in LAB by: NIn Kanong(k4n0ng)

#### Date: 24/08/2025
